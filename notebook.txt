Sunday 29th October

I've decided not to implement a complete solution for timestamps. For now, I'll keep the flat structure of phrases
and timestamp events and most consequences with current time. The exception is knowledge, which will get the timestamp
of the earliest phrase in the phrase list.

In practice, whenever we add consequences, whether for events or static knowledge, we give the timestamp of the record, the current
record.

As of now, there is no inferring from the knowledge base of a specific person. So even if John knows that Daryl went to Fiji,
he does not directly infer that Daryl is in Fiji. Instead we use inference from the static db (objective knowledge) to do that

Probably would make more sense to have a centralized step creation mechanism that includes events, inter-person questions, responses etc.
Attach a gens-type, such as stroy-step, knowledge insertion, etc.

Tuesday 31st October

Pushed the commit 'Answering personal questions'

An answer is generated but the next step is to add the contents of the answer as knowledge

Wednesday 1st November

Finished adding the answer to an inter-person query into the story database.

Will commit a version with above string

I intend to remove the generation of phrases for rules just for the purpose of learning because (1) that is about to change
and (2) some rules such as the knowledge resulting from telling rule generated millions of records.

A thought about time:
4 kinds of phrases:
state (as in John wants the wheel - that is always true)
current (as in Mike has the purse - this automatically updates its time. If it was true last stem, unless removed,
        it is true the next step. Note true for objective facts but not knowledge)
event (Harry went to the UK. Always has a specific time)
phase (Terry knows that Mile has the purse - this is true for a time. It can go out of date unless specifically updated)

Further note. Currently knows that has a time stamp of the object of the knowledge. We may need to break down a phrase into
constinuent pieces wach with their own time.


It doesn't make sense to have so many functions, each creating rules. There should only be one function for rule but many
differnt types that use something like the mostly defunct 'story_based, b_db, b_story'. Each step in the story advnacing process
must pick out the kind of rules it needs and advance them.

Next, I will add motivations. The current idea is:
(1) A steady state of wanting
(2) If you want x and you know that x is located in y you go to y
(3) If you want x and you are located with x and x is free pick up x
If you want x and you are located with x and z has x ask z for x

Thursday 2nd Nov

Rearrangin rules. Removed defunct b_db and b_story that weren't being used anyway. Added rule_type that falls into a number of categories:
story_start - used to initialize where people and objects are and what objects people want
event_from_none - used to create a story step (event) based on other states (rather that events responding to events)
state_from_state - update states based on other states. For example if Jon is in UK and glass is in UK then Jon knows glass is in UK
state_from_event - update states as a result of an event. Jon has the purse and Jon went to France, so create a story phrase that the purse is in France (remove old)
event_from_event - used to create a story step (event) based on another event (John gives if John is asked)
block_event - used to block events. So a rule that says that Jon gave to Jon is blocked
knowledge_query  - used in response to queries to first create a personal db of the knowledge of a particular person
query - used to test any knowledge base

used the opportunity to make rule indentations consistent

we need to replace var_id numbers by symbolic constants. A next step could be to translate this to he current form. It's
    just very difficult to write rles without bugs using the current form

While I'm at it, do the same for referring to clauses within the AND. It will be useful for time stamps

Added a probability for event_from_none rules so that we can prioiritize debugging or events that are caused by wants

Added a probability for state_from_event so that some rules don't automatically run after an event (e.g. like)

The are only two like states: likes and nothing.
Giving something to somebody that they want is definately gonna cause a like
Telling somebody something, which can only come after a question might get a like

Committing with the label:
Added likes and instory queries